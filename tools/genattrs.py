#!/usr/bin/env python3

import argparse
import json
import pprint
import attr
import sqlite3
import os
import re
import sys

import jinja2
import logging
import itertools

from genchars import Char
from tagger import Tagger

@attr.s
class Attribute(object):
    name: str = attr.ib()
    group: str = attr.ib()
    tagprefix: str = attr.ib()
    stateprefix: str = attr.ib()
    defaultstate: str = attr.ib(None)
    states = attr.ib(factory=list)
    tagid: int = attr.ib(default=-1)

@attr.s
class AttributeState(object):
    name: str = attr.ib()
    tagid: int = attr.ib()


class AttributeGen(object):
    def __init__(self, chars):
        self.tagger = Tagger(dict([(c.char, c) for c in chars]))
        self.chars = chars
        self.tags = ['INVALID']
        self.tagmap = {}
        self.tagidx = 1
        self.transmap = dict([(c.name, c.sv.capitalize()) for c in self.chars])
        self.transmap.update({
            # These are fixed up to use the terms used in the textual
            # transcriptions
            'interaction_type_angling': 'Vinkelkontakt',
            'interaction_type_diverging': 'Förs från varandra',
            'interaction_type_entering': 'Entré / Flätas',
            'interaction_type_converging': 'Förs mot varandra',
            'interaction_type_crossing': 'Korskontakt',
            'interaction_type_exchanging': 'Byter plats med varandra',
            'interaction_type_hooking': 'Hakas',
            'motion_type_circling': 'Förs i cirkel',
            'motion_type_curving': 'Förs i båge',
            'other_repetition': 'Upprepas',

            # Pseudo-tags generated by massage_tags
            'hands_one': 'En hand',
            'hands_two': 'Två händer, båda aktiva',
            'hands_two_but_one_active': 'Två händer, en aktiv',
            'position_hand': '(På den andra handen)',
            'position_unspecified': '(Neutrala läget framför kroppen)',

            'contact_unspecified': '(Ospecificerad kontakt)',

            'motion_type_moving': 'Förs',
            'motion_type_fingers': 'Fingrarna',

            'hands_any': 'En eller två händer',
            'position_any': 'Alla lägen',
            'handshape_any': 'Alla former',
            'attitude_pointed_any': 'Alla riktningar',
            'attitude_turned_any': 'Alla vändningar',

            'handshape_same': '(Samma handform)',
            'attitude_pointed_same': '(Samma riktning)',
            'attitude_turned_same': '(Samma vändning)',
            'attitude_pointed_symmetric': '(Symmetrisk riktning)',
            'attitude_turned_symmetric': '(Symmetrisk vändning)',

            # Titles for filters in UI
            '': '',
            'hands': 'Händer',
            'position': 'Läge',
            'right': 'Höger hand',
            'left': 'Vänster hand',
            'actions': 'Aktioner',
        })

    def massage_tag(self, t):
        if t.endswith('modifier_medial_contact'):
            return 'action-interaction_type_contact-modifier_medial_contact'
        if t == 'action-interaction_type_contact':
            return 'action-interaction_type_contact-contact_unspecified'

        if t.startswith('handshape'):
            return 'position_hand'

        # The states for these attributes are not complete.  See validate().
        if 'action-interaction_type_diverging-modifier' in t:
            return 'action-interaction_type_diverging'
        if 'position-relation' in t:
            return None

        parts = t.split('-')
        if len(parts) > 1 and parts[0] == 'action':
            if parts[1] in [
                'motion_backward',
                'motion_backward_short',
                'motion_rightward',
                'motion_rightward_short',
                'motion_downward',
                'motion_downward_short',
                'motion_depthwise',
                'motion_leftward',
                'motion_leftward_short',
                'motion_forward',
                'motion_forward_short',
                'motion_upward',
                'motion_upward_short',
                'motion_sideways',
                'motion_vertically',
                ]:
                direction = parts[1].split('_')[1]
                if direction == 'backward':
                    direction = 'backwards'
                parts[1] = 'motion_type_moving-modifier_' + direction
                return '-'.join(parts)
            elif parts[1] in [
                'motion_type_bending',
                'motion_type_playing',
                'motion_type_strewing',
                'motion_type_waving',
                ]:
                parts[1] = 'motion_type_fingers-' + parts[1]
                return '-'.join(parts)
            elif parts[1] in [
                'interaction_type_angling',
                'interaction_type_crossing',
                'interaction_type_entering',
                'interaction_type_hooking'
                ]:
                parts[1] = 'interaction_type_contact-' + parts[1]
                return '-'.join(parts)

        return t

    def massage_tags(self, sign, tags):
        tags = [self.massage_tag(t) for t in tags]
        tags = [t for t in tags if t]

        if sign.hands == 1:
            if sign.left:
                tags.append('hands_two_but_one_active')
            else:
                tags.append('hands_one')
        elif sign.hands == 2:
            tags.append('hands_two')

        if sign.left:
            if sign.left.shape == sign.right.shape:
                tags.extend(['left-handshape_same',
                             'right-handshape_same'])
            if sign.left.pointed == sign.right.pointed:
                tags.extend(['left-attitude_pointed_same',
                             'right-attitude_pointed_same'])
            if sign.left.turned == sign.right.turned:
                tags.extend(['left-attitude_turned_same',
                             'right-attitude_turned_same'])

            symmetric = [
                    ('forward', 'backward'),
                    ('backward', 'forward'),

                    ('leftward', 'rightward'),
                    ('rightward', 'leftward'),

                    ('upward', 'downward'),
                    ('downward', 'upward'),
            ]

            def direction(v):
                return v.split('_')[-1]

            if (direction(sign.left.pointed), direction(sign.right.pointed)) in symmetric:
                tags.extend(['left-attitude_pointed_symmetric',
                             'right-attitude_pointed_symmetric'])

            if (direction(sign.left.turned), direction(sign.right.turned)) in symmetric:
                tags.extend(['left-attitude_turned_symmetric',
                             'right-attitude_turned_symmetric'])

        if any(t for t in tags if 'motion_type_moving' in t):
            tags.append('action-motion_type_moving')

        if any(t for t in tags if 'fingers' in t):
            tags.append('action-motion_type_fingers')

        if any(t for t in tags if 'contact' in t):
            tags.append('action-interaction_type_contact')

        return sorted(list(set(tags)))

    def tag(self, signs):
        for sign in signs:
            sign['tagids'] = []

            idn = int(sign['id-nummer'])
            segs = self.tagger.tag(sign)
            if not segs:
                continue

            for seg in segs:
                assert seg.tags

                tags = self.massage_tags(seg, seg.tags)

                tagids = []
                for t in tags:
                    try:
                        v = self.tagmap[t]
                    except KeyError:
                        v = self.tagidx
                        self.tagmap[t] = self.tagidx
                        self.tags.append(t)
                        self.tagidx += 1

                    tagids.append(v)

                sign['tagids'].append(tuple(tagids))

        return signs

    def get_attribs(self):
        tags = list(self.tagmap.keys())

        attribs = [
            Attribute(name='hands',
                      group='',
                      defaultstate='hands_any',
                      tagprefix='hands_',
                      stateprefix=''),
            Attribute(name='position',
                      group='',
                      defaultstate='position_any',
                      tagprefix='position_',
                      stateprefix=''),
            Attribute(name='right',
                      group='right',
                      defaultstate='handshape_any',
                      tagprefix='right-handshape',
                      stateprefix='right-'),
            Attribute(name='right',
                      group='right',
                      defaultstate='attitude_pointed_any',
                      tagprefix='right-attitude_pointed',
                      stateprefix='right-'),
            Attribute(name='right',
                      group='right',
                      defaultstate='attitude_turned_any',
                      tagprefix='right-attitude_turned',
                      stateprefix='right-'),
            Attribute(name='left',
                      group='left',
                      defaultstate='handshape_any',
                      tagprefix='left-handshape',
                      stateprefix='left-'),
            Attribute(name='left',
                      group='left',
                      defaultstate='attitude_pointed_any',
                      tagprefix='left-attitude_pointed',
                      stateprefix='left-'),
            Attribute(name='left',
                      group='left',
                      defaultstate='attitude_turned_any',
                      tagprefix='left-attitude_turned',
                      stateprefix='left-'),
        ]

        actionattribs = []
        for t in tags:
            if not t.startswith('action-'):
                continue

            parts = t.split('-')
            if len(parts) > 2:
                continue

            action = parts[1]
            actionattribs.append(Attribute(name=action,
                                           group='actions',
                                           tagprefix=t,
                                           stateprefix=action))

        actionattribs = sorted(actionattribs, key=lambda a:self.transmap[a.name])
        attribs += actionattribs

        for attrib in attribs:
            for t in [t for t in tags if t.startswith(attrib.tagprefix)]:
                if 'short' in t and 'short' not in attrib.stateprefix:
                    print(attrib, t)
                    continue

                tags.remove(t)

                statename = t.replace('action-', '').replace(attrib.stateprefix, '').lstrip('-')
                if not statename or 'any' in statename and not attrib.defaultstate:
                    assert attrib.tagid == -1
                    attrib.tagid = self.tagmap[t]
                    continue

                state = AttributeState(name=statename, tagid=self.tagmap[t])
                attrib.states.append(state)

            attrib.states = sorted(attrib.states, key=lambda s:self.transmap[s.name])

        assert not any(a for a in attribs if a.defaultstate and a.tagid != -1)
        assert not any(a for a in attribs if not a.defaultstate and a.tagid == -1)
        if tags:
            pprint.pprint(tags)
        assert not tags

        return attribs

    def validate(self, attribs, signs):
        def signs_with_tag(tagid):
            if tagid == -1:
                return [s['id-nummer'] for s in signs if s['tagids']]

            return [s['id-nummer'] for s in signs if [seg for seg in s['tagids'] if tagid in seg]]

        for a in attribs:
            if not a.states or a.group == 'left':
                continue

            assert(len(a.states) > 1)

            match = sorted(signs_with_tag(a.tagid))
            assert(len(match))

            smatch = []

            for st in a.states:
                thismatch = signs_with_tag(st.tagid)
                assert len(thismatch) != len(match)
                smatch.extend(thismatch)

            smatch = sorted(set(smatch))
            if match != smatch:
                print(set(match) - set(smatch))
                print(a)
                print(len(match))
                print(len(smatch))
                assert False

    def gen(self, attribs):
        env = jinja2.Environment(trim_blocks=False, lstrip_blocks=True,
                                 undefined=jinja2.StrictUndefined)
        template = env.from_string('''
// Auto-generated.  Do not edit.

package `in`.rab.tsplex

object Attributes {
    val attributes = arrayOf(
    {% for attr in attribs %}
        Attribute(
            name = "{{ transmap[attr.name] }}",
            group = "{{ transmap[attr.group] }}",
            {% if attr.defaultstate %}
            defaultStateName = "{{ transmap[attr.defaultstate] }}",
            {% endif %}
            tagId = {{ attr.tagid }},
            states = arrayOf(
            {% for state in attr.states %}
                AttributeState(
                    name = "{{ transmap[state.name] }}",
                    tagId = {{ state.tagid }}
                ){% if not loop.last %},{% endif %}
            {% endfor %}
            )
        ){% if not loop.last %},{% endif %}
    {% endfor %}
    )
    val redundantTagIds = arrayOf(
    {% for tagid in redundant %}
        {{ tagid }}{% if not loop.last %},{% endif %}
    {% endfor %}
    )
}
'''.lstrip())

        redundant = ['-'.join(x) for x in itertools.product(('left', 'right'), \
                    ['handshape_same',
                     'attitude_pointed_same',
                     'attitude_turned_same',
                     'attitude_pointed_symmetric',
                     'attitude_turned_symmetric',
                     ])]

        return template.render(attribs=attribs, transmap=self.transmap,
                               redundant=[self.tagmap[t] for t in redundant])

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('--signs', default='signs.json')
    parser.add_argument('--chars', default='chars.json')
    parser.add_argument('-v', '--verbose', action='store_true')
    args = parser.parse_args()

    logging.basicConfig(level=logging.DEBUG if args.verbose else logging.INFO)

    with open(args.signs, 'r') as f:
        signs = json.load(f)

    with open(args.chars, 'r') as f:
        chars = [Char(**o) for o in json.load(f)]

    attgen = AttributeGen(chars)
    signs = attgen.tag(signs)
    attribs = attgen.get_attribs()

    attgen.validate(attribs, signs)

    pprint.pprint(sorted(attgen.tagmap.items(), key=lambda t:t[0]))
    print(attgen.gen(attribs))

if __name__ == '__main__':
    main()
